import Foundation

/// BetterEnvGenerator
/// Reads .env files and system environment variables, then generates Swift code.

struct EnvGenerator {
    let sourceDir: String
    let outputPath: String
    let envFilePatterns: [String]

    init(arguments: [String]) {
        // Arguments: sourceDir outputPath [envPatterns...]
        guard arguments.count >= 3 else {
            fputs("Usage: BetterEnvGenerator <sourceDir> <outputPath> [envPatterns...]\n", stderr)
            exit(1)
        }

        self.sourceDir = arguments[1]
        self.outputPath = arguments[2]
        self.envFilePatterns = arguments.count > 3
            ? Array(arguments[3...])
            : [".env", ".env.local", ".env.development", ".env.production"]
    }

    func run() throws {
        var environment: [String: String] = [:]

        // Read all .env files in order (later files override earlier ones)
        for pattern in envFilePatterns {
            let envPath = (sourceDir as NSString).appendingPathComponent(pattern)
            if let envVars = parseEnvFile(at: envPath) {
                for (key, value) in envVars {
                    environment[key] = value
                }
            }
        }

        // Also capture select system environment variables if specified in .env files with ${VAR} syntax
        // (The parsing already handles this)

        // Generate Swift code
        let code = generateSwiftCode(environment: environment)

        // Write to output file
        try code.write(toFile: outputPath, atomically: true, encoding: .utf8)

        print("BetterEnvGenerator: Generated \(environment.count) environment variables")
    }

    func parseEnvFile(at path: String) -> [String: String]? {
        guard FileManager.default.fileExists(atPath: path) else {
            return nil
        }

        guard let content = try? String(contentsOfFile: path, encoding: .utf8) else {
            fputs("Warning: Could not read \(path)\n", stderr)
            return nil
        }

        var result: [String: String] = [:]
        let lines = content.components(separatedBy: .newlines)

        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespaces)

            // Skip empty lines and comments
            if trimmed.isEmpty || trimmed.hasPrefix("#") {
                continue
            }

            // Parse KEY=VALUE
            guard let equalIndex = trimmed.firstIndex(of: "=") else {
                continue
            }

            let key = String(trimmed[..<equalIndex]).trimmingCharacters(in: .whitespaces)
            var value = String(trimmed[trimmed.index(after: equalIndex)...]).trimmingCharacters(in: .whitespaces)

            // Remove surrounding quotes if present
            if (value.hasPrefix("\"") && value.hasSuffix("\"")) ||
               (value.hasPrefix("'") && value.hasSuffix("'")) {
                value = String(value.dropFirst().dropLast())
            }

            // Handle variable substitution ${VAR}
            value = substituteVariables(in: value, environment: result)

            // Skip empty keys
            guard !key.isEmpty else {
                continue
            }

            result[key] = value
        }

        return result
    }

    func substituteVariables(in value: String, environment: [String: String]) -> String {
        var result = value
        let pattern = "\\$\\{([^}]+)\\}"

        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            return value
        }

        let matches = regex.matches(in: value, range: NSRange(value.startIndex..., in: value))

        // Process matches in reverse order to preserve indices
        for match in matches.reversed() {
            guard let varRange = Range(match.range(at: 1), in: value),
                  let fullRange = Range(match.range, in: value) else {
                continue
            }

            let varName = String(value[varRange])

            // Look up in already parsed env, then system env
            let replacement = environment[varName]
                ?? ProcessInfo.processInfo.environment[varName]
                ?? ""

            result = result.replacingCharacters(in: fullRange, with: replacement)
        }

        return result
    }

    func generateSwiftCode(environment: [String: String]) -> String {
        var code = """
        // Generated by BetterEnvGenerator
        // DO NOT EDIT - This file is automatically generated during build.
        // Regenerate by rebuilding your target.

        import Foundation
        import BetterEnvCore

        /// A namespace for accessing environment variables.
        /// Uses compile-time generated values first, then falls back to runtime environment.
        public enum BetterEnv {
            /// Compile-time environment values from .env files.

        """

        if environment.isEmpty {
            code += "    private static let compiled: [String: String] = [:]\n"
        } else {
            code += "    private static let compiled: [String: String] = [\n"
            let sortedKeys = environment.keys.sorted()
            for key in sortedKeys {
                guard let value = environment[key] else { continue }
                let escapedKey = escapeString(key)
                let escapedValue = escapeString(value)
                code += "        \"\(escapedKey)\": \"\(escapedValue)\",\n"
            }
            code += "    ]\n"
        }

        code += """

            // MARK: - Subscript Access (Compile → Runtime)

            /// Access an environment variable by key.
            /// Resolution order: Compiled → Runtime (does NOT check providers)
            /// - Parameter key: The environment variable name
            /// - Returns: The value of the environment variable
            /// - Note: Triggers fatalError if the key is not found.
            public static subscript(_ key: String) -> String {
                if let value = compiled[key] {
                    return value
                }
                if let value = ProcessInfo.processInfo.environment[key] {
                    return value
                }
                fatalError("BetterEnv: Environment variable '\\(key)' not found.")
            }

            // MARK: - Compile-time Access

            /// Access compile-time environment variables from .env files.
            public enum compile {
                /// Get a compile-time environment variable.
                /// - Parameter key: The environment variable name
                /// - Returns: The value if found, nil otherwise
                public static func get(_ key: String) -> String? {
                    compiled[key]
                }

                /// Get all compile-time environment variables.
                public static func getAll() -> [String: String] {
                    compiled
                }

                /// Check if a key exists in compile-time environment.
                public static func has(_ key: String) -> Bool {
                    compiled[key] != nil
                }
            }

            // MARK: - Runtime Access

            /// Access runtime environment variables from ProcessInfo.
            public enum runtime {
                /// Get a runtime environment variable.
                /// - Parameter key: The environment variable name
                /// - Returns: The value if found, nil otherwise
                public static func get(_ key: String) -> String? {
                    ProcessInfo.processInfo.environment[key]
                }

                /// Get all runtime environment variables.
                public static func getAll() -> [String: String] {
                    ProcessInfo.processInfo.environment
                }

                /// Check if a key exists in runtime environment.
                public static func has(_ key: String) -> Bool {
                    ProcessInfo.processInfo.environment[key] != nil
                }
            }

            // MARK: - Provider Access

            /// Add a provider for fetching environment variables.
            /// Providers are queried in order: first added = highest priority.
            /// - Parameter p: The provider to add
            public static func addProvider(_ p: any BetterEnvProvider) {
                BetterEnvRuntime.shared.addProvider(p)
            }

            /// Remove all registered providers.
            public static func removeAllProviders() {
                BetterEnvRuntime.shared.removeAllProviders()
            }

            /// Access a specific provider by type.
            /// - Parameter type: The provider type to access
            /// - Returns: A typed accessor for the provider
            public static func provider<T: BetterEnvProvider>(_ type: T.Type) -> ProviderAccessor<T> {
                ProviderAccessor(type: type)
            }

            /// Accessor for a specific provider type.
            public struct ProviderAccessor<T: BetterEnvProvider> {
                let type: T.Type

                /// Get an environment variable from this provider.
                /// - Parameter key: The environment variable name
                /// - Returns: The value if found, nil otherwise
                public func get(_ key: String) async throws -> String? {
                    guard let provider = BetterEnvRuntime.shared.getProvider(type) else {
                        return nil
                    }
                    return try await provider.get(key)
                }

                /// Get all environment variables from this provider.
                /// - Returns: Dictionary of all values from this provider
                public func getAll() async throws -> [String: String] {
                    guard let provider = BetterEnvRuntime.shared.getProvider(type) else {
                        return [:]
                    }
                    return try await provider.getAll()
                }
            }

            // MARK: - Combined Access

            /// Get an environment variable, checking all sources.
            /// Resolution order: Providers → Compiled → Runtime
            /// - Parameter key: The environment variable name
            /// - Returns: The value if found, nil otherwise
            public static func get(_ key: String) async throws -> String? {
                if let value = try await BetterEnvRuntime.shared.getFromProviders(key) {
                    return value
                }
                if let value = compile.get(key) {
                    return value
                }
                return runtime.get(key)
            }

            /// Get all environment variables from all sources.
            /// Resolution order: Providers → Compiled → Runtime
            /// - Returns: Merged dictionary of all values
            public static func getAll() async throws -> [String: String] {
                var result = runtime.getAll()
                for (key, value) in compile.getAll() {
                    result[key] = value
                }
                for (key, value) in try await BetterEnvRuntime.shared.getAllFromProviders() {
                    result[key] = value
                }
                return result
            }

            /// Check if a key exists in any source.
            /// - Parameter key: The environment variable name
            /// - Returns: true if the key exists in any source
            public static func has(_ key: String) async throws -> Bool {
                try await get(key) != nil
            }
        }

        """

        return code
    }

    func escapeString(_ string: String) -> String {
        var result = string
        result = result.replacingOccurrences(of: "\\", with: "\\\\")
        result = result.replacingOccurrences(of: "\"", with: "\\\"")
        result = result.replacingOccurrences(of: "\n", with: "\\n")
        result = result.replacingOccurrences(of: "\r", with: "\\r")
        result = result.replacingOccurrences(of: "\t", with: "\\t")
        return result
    }
}

// Main execution
let generator = EnvGenerator(arguments: CommandLine.arguments)
do {
    try generator.run()
} catch {
    fputs("Error: \(error.localizedDescription)\n", stderr)
    exit(1)
}
