import Foundation

/// BetterEnvGenerator
/// Reads .env files and system environment variables, then generates Swift code.

struct EnvGenerator {
    let sourceDir: String
    let outputPath: String
    let envFilePatterns: [String]

    init(arguments: [String]) {
        // Arguments: sourceDir outputPath [envPatterns...]
        guard arguments.count >= 3 else {
            fputs("Usage: BetterEnvGenerator <sourceDir> <outputPath> [envPatterns...]\n", stderr)
            exit(1)
        }

        self.sourceDir = arguments[1]
        self.outputPath = arguments[2]
        self.envFilePatterns = arguments.count > 3
            ? Array(arguments[3...])
            : [".env", ".env.local", ".env.development", ".env.production"]
    }

    func run() throws {
        var environment: [String: String] = [:]

        // Read all .env files in order (later files override earlier ones)
        for pattern in envFilePatterns {
            let envPath = (sourceDir as NSString).appendingPathComponent(pattern)
            if let envVars = parseEnvFile(at: envPath) {
                for (key, value) in envVars {
                    environment[key] = value
                }
            }
        }

        // Also capture select system environment variables if specified in .env files with ${VAR} syntax
        // (The parsing already handles this)

        // Generate Swift code
        let code = generateSwiftCode(environment: environment)

        // Write to output file
        try code.write(toFile: outputPath, atomically: true, encoding: .utf8)

        print("BetterEnvGenerator: Generated \(environment.count) environment variables")
    }

    func parseEnvFile(at path: String) -> [String: String]? {
        guard FileManager.default.fileExists(atPath: path) else {
            return nil
        }

        guard let content = try? String(contentsOfFile: path, encoding: .utf8) else {
            fputs("Warning: Could not read \(path)\n", stderr)
            return nil
        }

        var result: [String: String] = [:]
        let lines = content.components(separatedBy: .newlines)

        for line in lines {
            let trimmed = line.trimmingCharacters(in: .whitespaces)

            // Skip empty lines and comments
            if trimmed.isEmpty || trimmed.hasPrefix("#") {
                continue
            }

            // Parse KEY=VALUE
            guard let equalIndex = trimmed.firstIndex(of: "=") else {
                continue
            }

            let key = String(trimmed[..<equalIndex]).trimmingCharacters(in: .whitespaces)
            var value = String(trimmed[trimmed.index(after: equalIndex)...]).trimmingCharacters(in: .whitespaces)

            // Remove surrounding quotes if present
            if (value.hasPrefix("\"") && value.hasSuffix("\"")) ||
               (value.hasPrefix("'") && value.hasSuffix("'")) {
                value = String(value.dropFirst().dropLast())
            }

            // Handle variable substitution ${VAR}
            value = substituteVariables(in: value, environment: result)

            // Skip empty keys
            guard !key.isEmpty else {
                continue
            }

            result[key] = value
        }

        return result
    }

    func substituteVariables(in value: String, environment: [String: String]) -> String {
        var result = value
        let pattern = "\\$\\{([^}]+)\\}"

        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            return value
        }

        let matches = regex.matches(in: value, range: NSRange(value.startIndex..., in: value))

        // Process matches in reverse order to preserve indices
        for match in matches.reversed() {
            guard let varRange = Range(match.range(at: 1), in: value),
                  let fullRange = Range(match.range, in: value) else {
                continue
            }

            let varName = String(value[varRange])

            // Look up in already parsed env, then system env
            let replacement = environment[varName]
                ?? ProcessInfo.processInfo.environment[varName]
                ?? ""

            result = result.replacingCharacters(in: fullRange, with: replacement)
        }

        return result
    }

    func generateSwiftCode(environment: [String: String]) -> String {
        var code = """
        // Generated by BetterEnvGenerator
        // DO NOT EDIT - This file is automatically generated during build.
        // Regenerate by rebuilding your target.

        import Foundation
        import BetterEnvCore

        /// A namespace for accessing environment variables.
        /// Uses compile-time generated values first, then falls back to runtime environment.
        public enum BetterEnv {
            /// Compile-time environment values from .env files.

        """

        if environment.isEmpty {
            code += "    private static let compiled: [String: String] = [:]\n"
        } else {
            code += "    private static let compiled: [String: String] = [\n"
            let sortedKeys = environment.keys.sorted()
            for key in sortedKeys {
                guard let value = environment[key] else { continue }
                let escapedKey = escapeString(key)
                let escapedValue = escapeString(value)
                code += "        \"\(escapedKey)\": \"\(escapedValue)\",\n"
            }
            code += "    ]\n"
        }

        code += """

            // MARK: - Sync API (compile-time + runtime only)

            /// Access an environment variable by key.
            /// - Parameter key: The environment variable name
            /// - Returns: The value of the environment variable
            /// - Note: First checks compile-time values from .env files, then runtime ProcessInfo.
            ///         Triggers fatalError if the key is not found in either.
            ///         Does NOT check providers - use async `get(_:)` for that.
            public static subscript(_ key: String) -> String {
                if let value = compiled[key] {
                    return value
                }
                if let value = ProcessInfo.processInfo.environment[key] {
                    return value
                }
                fatalError("BetterEnv: Environment variable '\\(key)' not found. Check your .env files or system environment.")
            }

            /// Safely access an environment variable, returning nil if not found.
            /// - Parameter key: The environment variable name
            /// - Returns: The value if found, nil otherwise
            /// - Note: Does NOT check providers - use async `get(_:)` for that.
            public static func get(_ key: String) -> String? {
                if let value = compiled[key] {
                    return value
                }
                return ProcessInfo.processInfo.environment[key]
            }

            /// Access an environment variable only from the runtime environment, ignoring compile-time values.
            /// - Parameter key: The environment variable name
            /// - Returns: The runtime value if found, nil otherwise
            public static func runtimeGet(_ key: String) -> String? {
                return ProcessInfo.processInfo.environment[key]
            }

            /// Check if an environment variable exists (compile-time or runtime only).
            /// - Parameter key: The environment variable name
            /// - Returns: true if the key exists in either compile-time or runtime environment
            /// - Note: Does NOT check providers - use async `has(_:)` for that.
            public static func has(_ key: String) -> Bool {
                return compiled[key] != nil
                    || ProcessInfo.processInfo.environment[key] != nil
            }

            /// Get all compile-time environment variables.
            public static var compiledEnvironment: [String: String] {
                compiled
            }

            /// Get all available environment variables (compile-time + runtime, compile-time takes precedence).
            /// - Note: Does NOT include provider values - use async `all()` for that.
            public static var all: [String: String] {
                var result = ProcessInfo.processInfo.environment
                for (key, value) in compiled {
                    result[key] = value
                }
                return result
            }

            // MARK: - Provider Management

            /// Add a provider for fetching environment variables at runtime.
            /// Providers are queried in order: first added = highest priority.
            /// Provider values take precedence over compiled and runtime values.
            /// - Parameter provider: The provider to add
            public static func addProvider(_ provider: BetterEnvProvider) {
                BetterEnvRuntime.shared.addProvider(provider)
            }

            /// Remove all registered providers.
            public static func removeAllProviders() {
                BetterEnvRuntime.shared.removeAllProviders()
            }

            // MARK: - Async API (includes providers)

            /// Asynchronously get an environment variable, checking all sources.
            /// Resolution order: Providers (in order added) → Compiled → Runtime
            /// - Parameter key: The environment variable name
            /// - Returns: The value if found, nil otherwise
            public static func get(_ key: String) async throws -> String? {
                // Check providers first (highest priority)
                if let value = try await BetterEnvRuntime.shared.getFromProviders(key) {
                    return value
                }
                // Fall back to compiled
                if let value = compiled[key] {
                    return value
                }
                // Fall back to runtime
                return ProcessInfo.processInfo.environment[key]
            }

            /// Asynchronously check if an environment variable exists in any source.
            /// - Parameter key: The environment variable name
            /// - Returns: true if the key exists in providers, compile-time, or runtime environment
            public static func has(_ key: String) async throws -> Bool {
                return try await get(key) != nil
            }

            /// Asynchronously get all environment variables from all sources.
            /// Resolution order: Providers (in order added) → Compiled → Runtime
            /// - Returns: Merged dictionary of all values
            public static func all() async throws -> [String: String] {
                var result = ProcessInfo.processInfo.environment
                
                // Layer compiled on top
                for (key, value) in compiled {
                    result[key] = value
                }
                
                // Layer provider values on top (highest priority)
                let providerValues = try await BetterEnvRuntime.shared.getAllFromProviders()
                for (key, value) in providerValues {
                    result[key] = value
                }
                
                return result
            }
        }

        """

        return code
    }

    func escapeString(_ string: String) -> String {
        var result = string
        result = result.replacingOccurrences(of: "\\", with: "\\\\")
        result = result.replacingOccurrences(of: "\"", with: "\\\"")
        result = result.replacingOccurrences(of: "\n", with: "\\n")
        result = result.replacingOccurrences(of: "\r", with: "\\r")
        result = result.replacingOccurrences(of: "\t", with: "\\t")
        return result
    }
}

// Main execution
let generator = EnvGenerator(arguments: CommandLine.arguments)
do {
    try generator.run()
} catch {
    fputs("Error: \(error.localizedDescription)\n", stderr)
    exit(1)
}
